/// Tests for the inventory module.
#[test_only]
module inventory::inventory_tests {
    use sui::test_scenario::{Self as ts, Scenario};
    use inventory::inventory::{Self, PrivateInventory, VerifyingKeys};
    use inventory::registry::{Self, InventoryRegistry};

    const ADMIN: address = @0xAD;
    const USER1: address = @0x1;
    const USER2: address = @0x2;

    /// Create a dummy 32-byte commitment for testing
    fun dummy_commitment(seed: u8): vector<u8> {
        let mut commitment = vector::empty<u8>();
        let mut i = 0;
        while (i < 32) {
            vector::push_back(&mut commitment, seed);
            i = i + 1;
        };
        commitment
    }

    #[test]
    fun test_create_inventory() {
        let mut scenario = ts::begin(USER1);

        ts::next_tx(&mut scenario, USER1);
        {
            let commitment = dummy_commitment(1);
            let inv = inventory::create(commitment, ts::ctx(&mut scenario));

            assert!(inventory::owner(&inv) == USER1, 0);
            assert!(inventory::nonce(&inv) == 0, 1);
            assert!(*inventory::commitment(&inv) == dummy_commitment(1), 2);

            transfer::public_transfer(inv, USER1);
        };

        ts::end(scenario);
    }

    #[test]
    fun test_registry_spawn() {
        let mut scenario = ts::begin(ADMIN);

        // Initialize registry
        ts::next_tx(&mut scenario, ADMIN);
        {
            registry::init_for_testing(ts::ctx(&mut scenario));
        };

        // Spawn inventory through registry
        ts::next_tx(&mut scenario, USER1);
        {
            let mut registry = ts::take_shared<InventoryRegistry>(&scenario);

            let commitment = dummy_commitment(42);
            let inv = registry::spawn_inventory(&mut registry, commitment, ts::ctx(&mut scenario));

            assert!(registry::count(&registry) == 1, 0);
            assert!(inventory::owner(&inv) == USER1, 1);

            transfer::public_transfer(inv, USER1);
            ts::return_shared(registry);
        };

        // Spawn another inventory
        ts::next_tx(&mut scenario, USER2);
        {
            let mut registry = ts::take_shared<InventoryRegistry>(&scenario);

            let commitment = dummy_commitment(99);
            let inv = registry::spawn_inventory(&mut registry, commitment, ts::ctx(&mut scenario));

            assert!(registry::count(&registry) == 2, 0);

            transfer::public_transfer(inv, USER2);
            ts::return_shared(registry);
        };

        ts::end(scenario);
    }

    #[test]
    #[expected_failure(abort_code = inventory::inventory::EInvalidCommitmentLength)]
    fun test_invalid_commitment_length() {
        let mut scenario = ts::begin(USER1);

        ts::next_tx(&mut scenario, USER1);
        {
            // Try to create with invalid commitment length (not 32 bytes)
            let mut bad_commitment = vector::empty<u8>();
            vector::push_back(&mut bad_commitment, 1);
            vector::push_back(&mut bad_commitment, 2);

            let inv = inventory::create(bad_commitment, ts::ctx(&mut scenario));
            transfer::public_transfer(inv, USER1);
        };

        ts::end(scenario);
    }

    // Note: Full proof verification tests require actual circuit keys and proofs,
    // which would be generated by the Rust prover. These tests focus on the
    // Move contract logic itself.
}

#[test_only]
module inventory::registry_tests {
    use inventory::registry;

    /// Test-only initializer for registry
    public fun init_for_testing(ctx: &mut TxContext) {
        registry::init(ctx);
    }
}
