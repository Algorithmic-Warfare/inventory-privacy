//! Core reduction pass infrastructure.
//!
//! This module defines the `ReductionPass` trait - the fundamental unit of
//! the R1CS optimizer. Each pass scans for specific patterns and can transform
//! them into optimal forms while maintaining R1CS validity.

use ark_ff::PrimeField;
use std::fmt;

use crate::constraint::ConstraintMatrix;

/// A match found by a reduction pass during scanning.
#[derive(Clone, Debug)]
pub struct PatternMatch {
    /// Unique identifier for this match
    pub id: usize,
    /// Type of pattern matched
    pub pattern_type: PatternType,
    /// Constraint indices involved in this pattern
    pub constraint_indices: Vec<usize>,
    /// Variable indices involved (if applicable)
    pub variable_indices: Vec<usize>,
    /// Estimated constraint reduction if this match is reduced
    pub estimated_reduction: usize,
    /// Human-readable description of the match
    pub description: String,
    /// Additional metadata for the reduction algorithm
    pub metadata: MatchMetadata,
}

/// Types of patterns that can be matched.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum PatternType {
    /// Duplicate constraints (exact copies)
    Duplicate,
    /// Constant constraint (can be verified at compile time)
    Constant,
    /// Linear constraint (A=1 or B=1) that can be substituted
    LinearSubstitution,
    /// Dead variable (computed but never used)
    DeadVariable,
    /// Common subexpression (repeated linear combination)
    CommonSubexpression,
}

impl fmt::Display for PatternType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PatternType::Duplicate => write!(f, "Duplicate"),
            PatternType::Constant => write!(f, "Constant"),
            PatternType::LinearSubstitution => write!(f, "LinearSubstitution"),
            PatternType::DeadVariable => write!(f, "DeadVariable"),
            PatternType::CommonSubexpression => write!(f, "CommonSubexpression"),
        }
    }
}

/// Additional metadata needed for reduction.
#[derive(Clone, Debug, Default)]
pub struct MatchMetadata {
    /// For duplicates: the canonical constraint index to keep
    pub canonical_index: Option<usize>,
    /// For substitution: the variable to substitute
    pub substitute_variable: Option<usize>,
    /// For substitution: the expression (as term indices) to substitute with
    pub substitute_expression: Option<Vec<(usize, Vec<u8>)>>, // (var_idx, coeff_bytes)
    /// For CSE: the hash of the common expression
    pub expression_hash: Option<u64>,
}

/// Report generated by a reduction pass.
#[derive(Clone, Debug)]
pub struct ReductionReport {
    /// Name of the pass that generated this report
    pub pass_name: String,
    /// Total patterns found
    pub patterns_found: usize,
    /// Total constraints that can be reduced
    pub reducible_constraints: usize,
    /// Estimated constraint savings
    pub estimated_savings: usize,
    /// Detailed findings
    pub findings: Vec<String>,
}

impl ReductionReport {
    pub fn new(pass_name: impl Into<String>) -> Self {
        Self {
            pass_name: pass_name.into(),
            patterns_found: 0,
            reducible_constraints: 0,
            estimated_savings: 0,
            findings: Vec::new(),
        }
    }

    pub fn add_finding(&mut self, finding: impl Into<String>) {
        self.findings.push(finding.into());
    }
}

impl fmt::Display for ReductionReport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "┌─ {} ─", self.pass_name)?;
        writeln!(f, "│ Patterns found:      {}", self.patterns_found)?;
        writeln!(f, "│ Reducible constraints: {}", self.reducible_constraints)?;
        writeln!(f, "│ Estimated savings:   {}", self.estimated_savings)?;
        if !self.findings.is_empty() {
            writeln!(f, "│")?;
            writeln!(f, "│ Findings:")?;
            for (i, finding) in self.findings.iter().take(10).enumerate() {
                writeln!(f, "│   {}. {}", i + 1, finding)?;
            }
            if self.findings.len() > 10 {
                writeln!(f, "│   ... and {} more", self.findings.len() - 10)?;
            }
        }
        write!(f, "└─")?;
        Ok(())
    }
}

/// The fundamental unit of the R1CS optimizer.
///
/// A reduction pass:
/// 1. Scans the constraint matrix for specific patterns
/// 2. Reports what it found (informative layer)
/// 3. Reduces the patterns to their optimal form (transformation layer)
///
/// The separation of scan/reduce allows for:
/// - Dry-run analysis (scan + report only)
/// - Selective reduction (scan, filter matches, then reduce)
/// - Pass composition (run multiple scans, then batch reduce)
pub trait ReductionPass<F: PrimeField>: Send + Sync {
    /// Name of this reduction pass.
    fn name(&self) -> &'static str;

    /// Brief description of what this pass does.
    fn description(&self) -> &'static str;

    /// Scan the constraint matrix and find all matching patterns.
    ///
    /// This is the detection phase - it identifies patterns but does not
    /// modify the matrix.
    fn scan(&self, matrix: &ConstraintMatrix<F>) -> Vec<PatternMatch>;

    /// Apply reduction to the matrix based on the provided matches.
    ///
    /// This transforms the matrix, removing or simplifying constraints
    /// according to the matched patterns. The returned matrix is guaranteed
    /// to be semantically equivalent to the input (same satisfying assignments).
    ///
    /// # Arguments
    /// * `matrix` - The constraint matrix to reduce
    /// * `matches` - Pattern matches to apply (typically from `scan()`)
    ///
    /// # Returns
    /// A new, reduced constraint matrix.
    fn reduce(&self, matrix: ConstraintMatrix<F>, matches: &[PatternMatch]) -> ConstraintMatrix<F>;

    /// Generate an informative report about the scan results.
    ///
    /// This creates a human-readable summary of what patterns were found
    /// and what reductions are possible.
    fn report(&self, matches: &[PatternMatch]) -> ReductionReport {
        let mut report = ReductionReport::new(self.name());
        report.patterns_found = matches.len();
        report.reducible_constraints = matches.iter()
            .flat_map(|m| m.constraint_indices.iter())
            .collect::<std::collections::HashSet<_>>()
            .len();
        report.estimated_savings = matches.iter()
            .map(|m| m.estimated_reduction)
            .sum();

        for m in matches.iter().take(20) {
            report.add_finding(m.description.clone());
        }

        report
    }

    /// Convenience method: scan and reduce in one step.
    fn optimize(&self, matrix: ConstraintMatrix<F>) -> (ConstraintMatrix<F>, ReductionReport) {
        let matches = self.scan(&matrix);
        let report = self.report(&matches);
        let reduced = self.reduce(matrix, &matches);
        (reduced, report)
    }
}

/// Result of running the full optimization pipeline.
#[derive(Clone, Debug)]
pub struct OptimizationResult<F: PrimeField> {
    /// The optimized constraint matrix
    pub matrix: ConstraintMatrix<F>,
    /// Original constraint count
    pub original_constraints: usize,
    /// Final constraint count
    pub final_constraints: usize,
    /// Reports from each pass
    pub pass_reports: Vec<ReductionReport>,
}

impl<F: PrimeField> OptimizationResult<F> {
    /// Total constraints reduced
    pub fn constraints_reduced(&self) -> usize {
        self.original_constraints.saturating_sub(self.final_constraints)
    }

    /// Reduction percentage
    pub fn reduction_percentage(&self) -> f64 {
        if self.original_constraints == 0 {
            0.0
        } else {
            100.0 * self.constraints_reduced() as f64 / self.original_constraints as f64
        }
    }
}

impl<F: PrimeField> fmt::Display for OptimizationResult<F> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "╔══════════════════════════════════════════════════════════════╗")?;
        writeln!(f, "║                  R1CS OPTIMIZATION RESULT                    ║")?;
        writeln!(f, "╠══════════════════════════════════════════════════════════════╣")?;
        writeln!(f, "║ Original constraints:  {:>8}                             ║", self.original_constraints)?;
        writeln!(f, "║ Final constraints:     {:>8}                             ║", self.final_constraints)?;
        writeln!(f, "║ Reduced:               {:>8} ({:.1}%)                      ║",
            self.constraints_reduced(), self.reduction_percentage())?;
        writeln!(f, "╚══════════════════════════════════════════════════════════════╝")?;

        for report in &self.pass_reports {
            writeln!(f)?;
            write!(f, "{}", report)?;
        }

        Ok(())
    }
}
